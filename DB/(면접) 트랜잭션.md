# 트랜잭션이란?
    DBMS에서 데이터를 다루는 논리적인 작업의 단위
    트랜잭션은 데이터베이스의 무결성을 유지하기 위해 원자성, 일관성, 고립성, 지속성의 성질을 가짐

# 트랜잭션의 네 가지 성질(ACID)

    1. 원자성
        트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야함
    2. 일관성
        트랜잭션을 수행하기 전이나 수행한 후나 데이터베이스는 항상 일관된 상태를 유지해야함
    3. 고립성
        수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경 중인 데이터 값을 훼손하는일이 없어야 함
        (서로 다른 두 트랜잭션이 충돌하지 않도록 동시성 제어가 필요함)
    4. 지속성
        수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구적으로 저장해야함
        저장 직후 혹은 어느 때나 발생할 수 있는 정전, 장애, 오류에 영향을 받지 않아야 함
        (부분완료 상태에서 성공적으로 데이터를 데이터베이스에 저장하지 못하면 실패 상태가 되고, 
         실패 상태에서는 트랜잭션이 수행한 작업을 모두 원상복구 시킴)

![image](https://github.com/user-attachments/assets/f2593604-03e9-4150-b123-87fd691bcad4)    

# 트랜잭션의 존재 이유
    첫 째, 데이터베이스에서 데이터를 다룰 때 장애가 발생하는 경우, 트랜잭션이 데이터를 복구하는 작업의 단위가 됨

    둘 째, 여러 작업이 동시에 같은 데이터를 다루는 경우, 트랜잭션이 작업을 서로 분리하는 단위가 됨

# 트랜잭션 사용법
    트랜잭션을 사용하기 위한 문법은 START TRANSACTION문과 COMMIT문을 사용하여 트랜잭션의 시작과 끝을 표현함

    예시
    START TRANSACTION
        1. A 계좌에서 10000원을 인출하는 UPDATE 문
        2. B 계좌에서 10000원을 인출하는 UPDATE 문
    COMMIT

    위와 같이 작성하면 1,2번의 두 SQL문은 하나의 논리적인 작업의 단위가 됨

# 트랜잭션 수행 과정
![image](https://github.com/user-attachments/assets/77041c38-d6c0-47e4-ad49-75c34e5e8b81)

    트랜잭션이 수행되는 과정은 다음과 같음
    1. A계좌(박지성)의 값을 하드디스크(데이터베이스)에서 주기억장치 버퍼로 읽어옴
    2. B계좌(김연아)의 값을 하드디스크(데이터베이스)에서 주기억장치 버퍼로 읽어옴
    3. A계좌(박지성)에서 10,000원을 인출한 값을 저장함
    4. B계좌(김연아)에서 10,000원을 인출한 값을 저장함
    5. A계좌(박지성)의 값을 주기억장치 버퍼에서 하드디스크(데이터베이스)에 기록함
    6. B계좌(김연아)의 값을 주기억장치 버퍼에서 하드디스크(데이터베이스)에 기록함

    여기서 알아두어야 할 것은 트랜잭션의 사실적인 종료는 1~6이 완전히 끝난 후이지만,
    DBMS는 1~4까지 수행하고 사용자에게 부분완료 사실을 알리고, 나머지 5~6은 DBMS가 책임지고 수행함

    이렇게 작동하는 이유는 DBMS가 동시에 많은 트랜잭션을 처리할 때, 트랜잭션이 하드디스크에 개별접근하는 것을 막고
    DBMS가 일괄적으로 하드디스크에 접근하여 처리함으로써 사용자에게 빠른 응답성을 보장하기 위함
        
# 동시성 제어
    기본적으로 데이터베이스는 공유를 목적으로 하므로, 가능한 한 많은 트랜잭션을 동시에 수행시켜야 함
    하지만 여러 트랜잭션이 동시에 수행될 때 같은 데이터를 사용하게 되면 일관성 문제가 발생할 수 있음

    이러한 문제를 예방하기 위해 DBMS는 트랜잭션의 데이터 접근을 제어하는 동시성 제어를 사용함
![image](https://github.com/user-attachments/assets/18b423af-acf3-42bc-86ae-f3777e57ae94)

# 갱신손실 문제
    갱신손실 문제는 두 개의 트랜잭션이 한 개의 데이터를 동시에 갱신할 때 발생함
    갱신솔실 문제는 데이터베이스에서 절대 발생하면 안되는 문제임
![image](https://github.com/user-attachments/assets/26254567-62a8-4397-a775-c31981523faa)

# 락
    갱신손실 문제를 해결하기 위한 방법으로 락이라는 잠금장치를 사용함
    
    락은 트랜잭션이 데이터를 읽거나 수정할 때 데이터에 표시하는 잠금장치로,
    락을 이용하여 자신이 사용할 데이터를 잠그면 다른 트랜잭션은 잠금이 풀릴 때까지 기다려야 함
 ![image](https://github.com/user-attachments/assets/53410908-7da7-4490-a040-0be8bfc335fc)

# 락의 유형
    트랜잭션이 읽기를 할 때 사용하는 공유락(LS)와 트랜잭션이 쓰기(수정)을 할 때 사용하는 배타락(LX)이 있음

    트랜잭션이 LS를 걸어둔경우 LS의 요청은 허용하고 LX의 요청은 허용하지 않음
    반면, 트랜잭션이 LX를 걸어둔경우 LS와 LS의 요청 모두 허용하지 않음

    트랜잭션이 락의 허용을 받지 못하면 대기 상태가 됨
![image](https://github.com/user-attachments/assets/6316e66e-691e-48cb-b317-def0c91d5dab)

# 2단계 락킹
    데이터가 락을 걸었다가 풀고 다시 거는 중간 과정에 락의 해지 상태가 생기면서
    다른 트랜잭션에 중간결과를 보일 수 있기 때문에, 이를 예방하기 위해 2단계 락킹을 사용함
    
    2단계 락킹은 트랜잭션이 필요한 락을 획득하는 확장단계와, 트랜잭션이 락을 해제하는 수축단계로 나누어짐
![image](https://github.com/user-attachments/assets/594641fa-4026-4edc-9d4a-8b4d957e1fa7)
![image](https://github.com/user-attachments/assets/6b49e44c-cd16-4c10-a73d-6a4441f18935)

# 데드락
    2개 이상의 트랜잭션이 각각 자신의 데이터에 대해 락을 획득하고 상대방 데이터에 대해
    락을 요청하면 무한대기 상태에 빠지게 됨

    이러한 현상을 데드락 또는 교착상태라고 표현
![image](https://github.com/user-attachments/assets/e0d0bc62-c9f4-457d-b04c-0a01d57408e8)

    일반적으로 데드락이 발생하면 두 개의 트랜잭션 중 하나를 강제로 중지시킴
    중지된 트랜잭션이 변경한 데이터는 원래의 값으로 돌림

    데드락은 대기 그래프로도 판단할 수 있는데, 만약 대기 그래프 상에 사이클이 존재한다면 데드락이 발생한 것
    
# 트랜잭션 고립 수준
    트랜잭션 1에서 읽기만 하는 경우 갱신손실과 같은 심각한 문제는 발생하지 않지만,
    dirty read, non-repeatable read, phantom read와 같은 문제가 발생할 수 있음

## dirty read(오손 읽기)
    작업중이던 트랜잭션 2가 어떠한 이유로 ROLLBACK 할 경우, 트랜잭션 1은 무효가 된 데이터를 읽게 되고, 잘못된 결과를 도출함
    아래 예시와 같이 트랜잭션 2는 21로 바꾸었던 홍길동의 나이 값을 철회하고자 하였으나, 트랜잭션1이 철회하기 전 값을 조회하여 잘못된 결과를 도출하였음
![image](https://github.com/user-attachments/assets/bf216209-cc36-45e6-90c4-3ea2810cdeaf)

## non-repeatable read(반복불가능 읽기)
    트랜잭션 1이 데이터를 읽고 작업하는 도중 트랜잭션 2가 데이터를 갱신하면, T1 입장에서 같은 SQL문이 다른 결과를 도출하게 됨
    물론, COMMIT을 한 이후의 데이터이기 때문에 틀린 데이터는 아니지만, T1의 입장에서 동일한 SQL문이 다른 결과를 도출한다는 것이 포인트
![image](https://github.com/user-attachments/assets/3ae9b1d1-415e-448b-90b2-b39fc78e5dd6)

## phantom read(유령 읽기)
    트랜잭션 1이 데이터를 읽고 작업하는 도중 트랜잭션 2가 새로운 데이터를 추가하면, 
    T1 입장에서는 새로운 데이터가 반영되어 반복불가능 읽기와 마찬가지로 동일한 SQL문이 다른 결과를 도출함
    마찬가지로, COMMIT을 한 이후의 데이터이기 때문에 틀린 데이터는 아니지만, T1의 입장에서는 동일한 SQL문이 다른 결과를 도출한다는 것이 포인트
![image](https://github.com/user-attachments/assets/58190a26-4e91-4385-8750-a4afaf9d7e91)

# 트랜잭션 고립 수준 명령어
![image](https://github.com/user-attachments/assets/63422cac-83f7-42a2-a1f1-210ecb03677b)
    SQL 표준에서는 위와 같이 네 가지 고립 수준을 정의하고 있지만, ORACLE에서는 READ COMMITED와 SERIALIZABLE 모드만을 제공함

## READ UNCOMMITTED(LEVEL=0)
![image](https://github.com/user-attachments/assets/4e69947b-1e94-4ced-9f9a-1b50009e0b26)

## READ COMMITTED(LEVEL=1)
![image](https://github.com/user-attachments/assets/21dd8f5b-805e-46fd-9704-f606ff6337b9)

## REPEATABLE READ(LEVEL=2)
![image](https://github.com/user-attachments/assets/e0526506-8713-4f51-a063-5b3c2281ff49)

## SERIALIZABLE(LEVEL=3)
![image](https://github.com/user-attachments/assets/1b286133-bf80-4f8a-9639-eb6f30015c6c)
