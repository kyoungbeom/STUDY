# 프로세스란?
- 보조기억장치에 있는 프로그램이 메모리에 적재되고 실행되는 순간 프로세스가 됨

![image](https://github.com/user-attachments/assets/7577c7ca-25be-47e7-a4c4-89acf8259e5f)

- 사용자가 보는 앞에서 실행되는 프로그램은 '포그라운드 프로세스' 라고 함
- 사용자가 보지 못하는 뒤에서 실행되는 프로그램은 '백그라운드 프로세스' 라고 함
- '백그라운드 프로세스' 중에서 사용자와 직접적으로 상호작용하지 않고, <br>
  혼자 동작하는 프로세스를 유닉스 운영체제에서는 '데몬 프로세스', 윈도우 운영체제에서는 '서비스 프로세스' 라고 부름

# 프로세스 제어 블록
- CPU의 자원은 한정되어 있, 이 한정된 자원을 나눠쓰기 위해서 타이머 인터럽트가 발생함
- 이때, 운영체제는 번갈아 수행되는 프로세스의 실행 순서를 관리하고, 프로세스에 CPU를 비롯한 자원을 배분함

![image](https://github.com/user-attachments/assets/108929dd-9ecc-4f5d-85e1-ed60f7b88466)

- 이를 위해 운영체제는 '프로세스 제어 블록(Process Control Block : PCB)'를 이용함
- '프로세스 제어 블록' 에는 특정 프로세스를 식별하기 위해 꼭 필요한 정보들이 저장됨

# PCB에 저장되는 정보
## 프로세스 ID (Process ID : PID)
- 특정 프로세스를 식별하기 위해 부여하는 고유한 번호임
- 같은 프로그램이라도 두 번 실행하면 서로 다른 PID를 가진 프로세스가 생성됨

## 레지스터 값
- 프로세스는 자신의 차례가 돌아오면 이전까지 사용했던 레지스터 중간값들을 모두 복원해야 하기 때문에 PCB에 레지스터 값들을 저장함

## 프로세스 상태
- 현재 프로세스가 어떤 상태인지를 저장함(입출력 대기, CPU 사용 대기 등)
  
## CPU 스케줄링 정보
- 프로세스가 언제, 어떤 순서로 CPU를 할당받을지 저장함
  
## 메모리 관리 정보
- 프로세스마다 메모리에 저장된 위치가 다르기 때문에, 프로세스가 어느 주소에 저장되는지 저장함

## 사용한 파일과 입출력장치 목록
- 프로세스 실행 과정에서 특정 입출력장치나 파일을 사용하면 PCB에 해당 내용이 저장

![image](https://github.com/user-attachments/assets/96b685c3-fd8c-4fde-ad14-fa73fc0a675d)

# 문맥 교환
- 타이머 인터럽트에 의해 프로세스가 변경될 때, 다음번에 프로세스 수행을 재개하기 위해 여러가지 정보를 저장해야하는데, 이 정보들을 '문맥' 이라고 함
- 하나의 프로세스 문맥은 해당 프로세스의 PCB에 표현되어 있기 때문에, PCB에 기록되는 정보를 문맥이라고 봐도 무방함
- CPU를 사용할 수 있는 시간이 다 되거나 예상치 못한 오류가 발생해 인터럽트가 발생하면 운영체체는 해당 프로세스의 PCB에 문맥을 백업하고, <br>
  다음에 실행될 프로세스의 PCB에서 문맥을 복구하여 실행

![image](https://github.com/user-attachments/assets/2a220e96-ca16-456f-ad6b-65a54af73492)
![image](https://github.com/user-attachments/assets/4a4e1833-e136-4811-9e84-a96d3a913fac)

# 프로세스의 메모리 영역
- 프로세스가 생성되면 커널 영역에는 PCB가 생성되고, 사용자 영역에는 크게 '코드 영역', '데이터 영역', '힙 영역', '스택 영역' 으로 나뉘어 저장됨

## 정적 할당 영역
- 크기가 고정된 영역으로, 코드 영역과 데이터 영역이 정적 할당 영역에 해당함

### 코드 영역 (텍스트 영역)
- 기계어로 이루어진 명령어, CPU가 실행할 명령어가 저장됨
- 코드 영역에는 CPU가 실행할 명령어가 담겨 있기 때문에 쓰기가 금지되어 있고 오직 읽기만 가능함

### 데이터 영역
- 프로그램이 실행되는 동안 사용할 데이터가 저장됨
- 대표적인 데이터로는 전역변수가 있음. 전역변수는 프로그램이 실행되는 동안 유지되며, 프로그램 전체에서 접근할 수 있는 변수임

## 동적 할당 영역
- 크기가 변할 수 있는 영역으로, 힙 영역과 스택 영역이 동적 할당 영역에 해당함

### 힙 영역
- 프로그램을 만드는 사용자, 프로그래머가 직접 할당할 수 있는 공간임
- 프로그래밍 과정에서 힙 영역에 메모리 공간을 할당했다면 언젠가는 해당 공간을 반환해야함 <br>
  만약, 메모리 공간을 반환하지 않는다면 할당된 공간이 메모리 내에 계속 남아 메모리 낭비를 초래함 <br>
  이러한 문제를 '메모리 누수' 라고 함

![image](https://github.com/user-attachments/assets/21a34a9d-08d5-4183-a249-1fc95f234c3e)

### 스택 영역
- 데이터를 임시적으로 저장하는 공간으로, <br>
  데이터 영역과는 달리 잠깐 쓰이고 말 값들이 저장되는 공간임
- 매개 변수와 지역 변수가 대표적인 예시임

# 프로세스 상태

## 생성 상태
- 프로세스를 생성 중인 상태를 '생성 상태(new)' 라고 함
- 이제 막 메모리에 적재되어 PCB를 할당받은 상태임

## 준비 상태
- 자신의 차례가 아니기에 기다리고 있는 상태를 '준비 상태(ready)' 라고 함
- 준비 상태 프로세스는 차례가 되면 CPU를 할당받아 실행 상태가 됨
- 준비 상태에서 실행 상태로 전환되는 것을 '디스패치' 라고 함

## 실행 상태
- CPU를 할당 받아 실행중인 상태를 '실행 상태' 라고 함

## 대기 상태
- 프로세스가 실행 도중 입출력 장치를 사용하는 경우, 입출력 장치의 입출력이 끝날 때까지 프로세스는 대기해야하고 이런 상태를 '대기 상태' 리고 함

## 종료 상태
- 프로세스가 종료된 상태로, 운영체체가 PCB와 프로세스가 사용한 메모리를 정리

![image](https://github.com/user-attachments/assets/a87f4abd-c445-416f-a512-1ff86b99576c)

# 프로세스 계층 구조
- 프로세스 실행 도중 시스템 호출을 통해 다른 프로세스를 생성하는 경우, <br>
  새 프로세스를 생성한 프로세스를 '부모 프로세스', 부모 프로세스에 의해 생성된 프로세스를 '자식 프로세스' 라고 함
- 부모와 자식 프로세스는 각기 다른 PID를 가짐. 일부 운영체제에서는 자식 프로세스의 PCB에 부모 프로세스의 PID인 PPID(Parent PID)가 저장되기도 함
- 이렇듯 프로세스는 부모 프로세스가 자식 프로세스를 만들고, 그 자식 프로세스가 부모가 되어 또 자식 프로세스를 만들어 프로세스 계층 구조를 가짐

![image](https://github.com/user-attachments/assets/bd4bc3be-a57f-4342-8c16-9a26ea25dbc5)

# 프로세스 생성 기법
- 부모 프로세스는 fork를 통해 자신의 복사본을 자식 프로세스로 생성해내고, <br>
  만들어진 자식 프로세스(만들어진 복사본)은 exec를 통해 자신의 메모리 공간을 다른 프로그램으로 교체함

## fork
- fork는 자시 자신 프로세스의 복사본을 만드는  시스템 호출임
- 부모 프로세스의 자원들, 메모리의 내용, 열린 파일 목록 등이 자식 프로세스에 상속되지만, PID 값이나 저장된 메모리의 위치는 다름

![image](https://github.com/user-attachments/assets/d6032b78-c1a1-40c4-a604-7b339346d650)

## exec
- exec은 자신의 메모리 공간을 새로운 프로그램으로 덮어쓰는 시스템 호출임
- exec을 호출하면 코드 영역과 데이터 영역의 내용이 실행할 프로그램의 내용으로 바뀌고, 나머지 영역은 초기화됨

![image](https://github.com/user-attachments/assets/14cdb764-f494-4933-9d50-c41c9dfd5ec2)
![image](https://github.com/user-attachments/assets/f12cfff9-2bd1-41e0-ba49-6cac784a56c9)
