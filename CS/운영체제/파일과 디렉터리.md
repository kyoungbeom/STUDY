# 파일이란?
     하드디스크나 SSD와 같은 보조기억장치에 저장된 관련 정보의 집합 
     또는 관련있는 정보를 모은 논리적 단위

     파일은 기본적으로 이름. 파일을 실행하기 위한 정보, 파일 관련 부가정보가 있음

     여기서 부가 정보를 속성 또는 메타데이터라고 부름

     파일은 반드시 운영체제에 의해서만 다루어질 수 있으며,
     운영체제는 파일 연산을 위해 시스템 호출을 제공함
![image](https://github.com/user-attachments/assets/9aef410e-185f-4421-a30a-a285fa694f6d)

# 파일 속성과 유형
![image](https://github.com/user-attachments/assets/96c2b28e-f32c-442f-afec-78a4f40616cb)

     파일유형은 운영체제가 인식하는 파일의 종류로, 주로 확장자를 사용해 파일의 유형을 정의함
![image](https://github.com/user-attachments/assets/2c55b9bb-7b9c-4545-9aad-23bddd4d8a14)

# 디렉토리
     파일을 관리하기 위해 디렉토리를 사용함
     윈도우에서는 이 디렉토리를 폴더라고 부름

     운영체제가 파일의 연산을 위해 시스템 호출을 제공하는 것처럼
     운영체제는 디렉토리의 연산을 위한 시스템 호촐 또한 제공함
     
     과거에는 1단계 디렉터리 구조였지만, 현재에는 트리 구조 디렉토리를 사용함

     트리 구조 디렉토리에서는 최상위 디렉토리를 흔히 루트 디렉토리라고 부르고 슬래시(/)로 표현함
     이와 관련하여 자연스럽게 생긴 개념이 경로임

# 절대 경로와 상대 경로
     모든 파일은 루트 디렉토리에서 자기 자신까지 이르는 고유한 경로를 가지고 있고, 이를 절대경로라고 함
     반면, 현재 디렉토리부터 시작하는 경로를 상대경로라고 함
  
# 디렉토리 엔트리
     디렉토리 또한 파일의 한 종류로, 포함된 정보가 조금 특별한 파일임

     디렉토리는 보조기억장치에 테이블 형태의 정보로 저장됨

     디렉토리 엔트리(행)에 담기는 정보는 파일 시스템마다 차이가 있음
![image](https://github.com/user-attachments/assets/728e216e-f07c-4226-9ce8-8127f92edb51)

     아래의 예시를 참고하면 보다 이해하기 쉬울 것임

![image](https://github.com/user-attachments/assets/0ca8df6a-0556-4c94-a4e4-96bc2da9d371)
![image](https://github.com/user-attachments/assets/20eb1c33-2d36-4534-9925-94cdd38055de)

# 파일 시스템
     파일시스템은 파일과 디렉토리를 보조기억장치에 일목요연하게 저장하고,
     접근할 수 있게 하는 운영체제 내부 프로그램임

     파일 시스템은 여러 종류가 있고, 하나의 컴퓨터에서 여러 파일 시스템읈 사용할 수 있음

# 파티셔닝과 포매팅
     한 번도 사용된 적 없는 보조기억장치를 사용하려면 파티션을 나누는 작업(파티셔닝)과 포맷 작업(포맷팅)을 거쳐야 함
     
     파티셔닝이란 저장 장치의 논리적인 영역을 구획하는 작업 
     쉽게 말해 칸막이로 영역을 나누는 작업과 같음

     파티셔닝을 통해 나누어진 영역 하나하나를 파티션이라고 함

     포매팅이란 파일 시스템을 설정하여 어떤 방식으로 파일을 저장하고 관리하는 것인지르 결정하고,
     새로운 데이터를 쓸 준비를 하는 작업임

     흔히 알고 있는 저장 장치를 완전히 삭제되는 것은 완벽한 표현이 아님

![image](https://github.com/user-attachments/assets/1cf5199b-b919-4c6a-be7e-06bd08f4acec)

     파티션 별로 파일시스템을 다르게 해서 사용할 수 있음
![image](https://github.com/user-attachments/assets/0ea6ad54-87df-417e-b292-1f2baa36237e)

# 파일 할당 방법
     운영체제는 파일과 디렉토리를 블록 단위로 읽고 씀

     크기가 작은 파일은 적은 수의 블록에 걸쳐 저장되고,
     크기가 큰 파일은 여러 블록에 걸쳐 저장됨

     파일을 보조기억장치에 할당하는 방법은 연속할당과 불연속 할당으로 나뉨
![image](https://github.com/user-attachments/assets/c9f09a71-7f4c-41b6-998f-31b9de38ab7a)

# 연속 할당
     연속 할당은 말그대로 보조기억장치 내 연속적인 블록에 파일을 할당하는 방식임
     연속 할당에서는 할당된 파일에 접근하기 위해 첫 번째 블록 주소와 블록 단위의 길이만을 알면 됨
![image](https://github.com/user-attachments/assets/de60da61-f6b7-4aaf-b461-4878297ce36b)

     연속 할당은 파일을 그저 연속적으로 할당하는 방식이기 때문에,
     구현이 간단하다는 장점이 있지만, 외부 단편화를 야기한다는 치명적인 단점이 있음
  
![image](https://github.com/user-attachments/assets/87b4bd81-b7d2-481e-9a24-29b2c909b4dc)
![image](https://github.com/user-attachments/assets/c51d7a3c-e4aa-43a4-8da2-3ab751fd413c)

     위 이미지에서도 알 수 있듯이 파일 D와 F가 삭제되면 할당할 수 있는 블록은 열한 개가 남지만,
     크기가 일곱 개 이상을 사용하는 파일은 할당할 수가 없음

 # 연결 할당
     연속 할당의 문제를 해결할 수 있는 방식이 연결 할당임
     연결할당은 각 블록 일부에 다음 블록의 주소를 저장하여 각 블록이 다음 블록을 가리키는 형태로 할당하는 방식임

     즉, 파일을 이루는 데이터를 연결 리스트로 관리함

     연결 할당은 불연속 할당의 일종이기에 파일이 여러 블록에 흩어져 저장되어도 무방함

     물론 이러한 연결 할당에도 명백한 단점이 존재함

     첫 째, 반드시 첫 번째 블록부터 하나씩 차례대로 읽어야 함
     만약 i 번째 블록에 접근하자고 한다면 첫 번째 블록부터 i 번째 블록까지 일일이 순서대로 접근해야함
     즉, 임의 접근 속도가 매우 느림

     둘 째, 하드웨어 고장이나 오류 발생 시 다음 블록에 접근할 수 없음
     하나의 블록안에 파일 데이터와 다음 블록 주소가 모두 포함되어 있다 보니,
     하드웨어 고장이나 오류로 인해 블록에 하나라도 문제가 발생하면 그 블록 이후의 블록에 접근할 수 없

![image](https://github.com/user-attachments/assets/ce86c3da-d99e-493f-a6d5-36da850ef30e)
   
# 색인 할당
     색인 할당은 파일의 모든 블록 주소를 색인 블록이라는 하나의 블록에 모아 관리하는 방식

     색인 블록은 임의의 위치에 접근하기 쉬움
     만약 파일의 i번째 데이터에 접근하고 싶다면 색인 블록의 i번째 항목이 가리키는 블록에 접근하면 
![image](https://github.com/user-attachments/assets/5c614b4d-c4b0-4677-8ef6-6af53f1815d6)

     색인 할당을 사용하는 파일 시스템에서는 디렉토리 엔트리에 파일 이름과 더불어 색인 블록 주소를 명시

![image](https://github.com/user-attachments/assets/77a19e79-ba45-45d6-b647-04590db58aa2)
     
