# 연속 메모리 할당
    프로세스에 연속적인 메모리 공간을 할당하는 방식

![image](https://github.com/user-attachments/assets/143007db-5087-4f53-bd77-88bb967acf4a)

# 스와핑
    대기상태 프로세스나 오랫동안 사용되지 않은 프로세스를 임시로 보조기억장치 일부 영역으로 쫓아내고,
    그렇게 해서 생긴 메모리 상의 빈공간에 다른 프로세스를 적재하여 실행하는 방식

    이때 프로세스들이 쫓겨나는 보조기억장치의 일부를 스왑 영역이라 하고,
    메모리에서 스왑 영역으로 프로세스가 옮겨지는 것을 스왑 아웃,
    스왑 영역에서 메모리로 프로세스를 옮겨오는 것을 스왑 인이라고 함

    스왑 아웃 되었던 프로세스가 다시 스왑 인이 될 때는 기존 물리 주소와 다른 주소에 적재될 수 있음

![image](https://github.com/user-attachments/assets/175a0d0a-57fa-48fd-bf6a-fa419f4951f4)

# 메모리 할당 방식
    1. 최초 적합
       운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식
![image](https://github.com/user-attachments/assets/576edcda-34df-4934-a338-9a3fc88e5237)
       
    2. 최적 적합
       운영체제가 메모리 내의 빈 공간을 모두 검색하고 
       적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방식
![image](https://github.com/user-attachments/assets/2b5870f5-f5bb-4e84-9fca-8a5a57958158)

    3. 최악 적합
       운영체제가 메모리 내의 빈 공간을 모두 검색하고
       적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식
![image](https://github.com/user-attachments/assets/c6b0f021-48ee-4872-a55c-a559bcf1373e)

# 외부 단편화
![image](https://github.com/user-attachments/assets/00951d4d-278b-4519-a05f-978789d087f9)

    그림에서 남아있는 메모리 공간은 50MB이지만, 정작 어느 빈 공간에도 50MB 크기의 프로세스가 적용될 수 없음
    
    이렇듯 메모리를 연속적으로 할당하면 프로세스가 실행되고 종료되는 과정에서 메모리 상에 빈 공간이 생기지만,
    그 빈 공간보다 큰 프로세스들을 적재하기 어려운 상황을 초래하고 메모리 낭비로 이어짐

    이를 외부 단편화라고 함

# 압축 
    앞서 설명한 외부 단편화를 해결할 수 있는 대표적인 방안으로 압축이 있음
    
    압축은 여기저기 흩어져 있는 빈 공간들을 하나로 모으는 방식으로,
    메모리 내에 저장된 프로세스를 적당히 재배치시켜 여기저기 흩어져 있는 작은 빈공간들을 하나의 큰 빈공간으로 만듦

    물론 작은 빈 공간을 하나로 모으는 동안 시스템은 하던 일을 중지해야하고, 
    메모리 내에 있는 내용을 옮기는 작업은 많은 오버헤드를 야기하기 때문에 
    이러한 단점들을 극복하고자 가상 메모리 기법, 그 중에서도 페이징 기법이 등장함

# 가상메모리
    실행하고자 하는 프로그램의 일부만 메모리에 적재하여 실제 메모리 크기보다 더 큰 프로세스를 실행할 수 있도록 하는 기술

    가상메모리 관리기법에는 크게 페이징과 세그멘테이션이 있음

# 페이징이란
    프로세스의 논리 주소 공간을 페이지라는 일정한 단위로 자르고,
    메모리 물리 주소 공간을 프레임이라는 페이지와 동일한 크기의 일정한 단위로 자른뒤 페이지를 프레임에 할당하는 방법

![image](https://github.com/user-attachments/assets/5285855b-8340-4012-abbc-88cacaeaa359)

    페이징에서도 앞서 설명한 스와핑이 이루어짐
    페이징시스템에서의 스왑 아웃은 페이지 아웃, 스왑 인은 페이지 인이라고 부르기도 함

![image](https://github.com/user-attachments/assets/a243a783-906b-4380-82c3-d5cd7bfd77d5)

    페이징을 사용하게 되면 프로세스 전체를 메모리에 올릴 필요가 없어지고,
    필요한 페이지 단위로 메모리에 적재하여 실행할 수 있기 때문에
    이를 통해 실제 메모리 용량보다 더 큰 프로세스를 실행할 수 있게 됨

# 더 알아보기
![image](https://github.com/user-attachments/assets/d10fa037-ceae-49ec-ae21-a13e0dbb55c2)    

# 페이지 테이블
    프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지
    CPU의 입장에서 모두 알고 있기 힘들기 때문에 페이지 테이블을 사용하여
    페이지 번호와 프레임 번호를 짝지어 줌

    메모리의 물리주소가 불연속적이더라도 논리주소에는 연속적으로 배치되도록 함
    CPU 입장에서는 프레임들이 메모리에 분산 저장되어 있다고 해도 논지 주소를 순차적으로 실행하면됨

![image](https://github.com/user-attachments/assets/d531d25c-ae4b-45b2-b660-323f2223a291)

    프로세스마다 각자의 페이지 테이블을 가지고 있고, 이 페이지 테이블들은 메모리에 적재되어 있음
    그리고 CPU 내의 페이지 테이블 베이스 레지스터(PTBR)은 프로세스 페이지의 테이블이 적재된 주소를 가킴

![image](https://github.com/user-attachments/assets/2c115bde-9f61-4a7a-80ba-6c2faa3184c8)
    
    물론 이렇게 페이지 테이블을 메모리에 적재해두면, 메모리에 있는 페이지 테이블을 보기 위해 한 번
    이 페이지 테이블을 통해 알게된 프레임에 접근하기 위해 한 번, 총 두 번의 메모리 접근이 필요하게 되어 비효율적임

    이러한 문제를 해결하기 위해 CPU 곁에 TLB라는 페이지 테이블의 캐시 메모리를 둠
    
    이 TLB에서는 페이지 테이블 일부 내용을 저장함.
    이때, 발생한 논리주소에 대한 페이지 번호가 저장된 내용에 있을 경우를 TLB 히트라고 하고,  
    페이지 번호가 TLB에 없을 경우를 TLB 미스라고 함 
    
![image](https://github.com/user-attachments/assets/bc030773-d35d-4bfa-8bcb-8006e1b2f28f)
    
# 더 알아보기
![image](https://github.com/user-attachments/assets/b8dfcaf4-4045-49be-8c48-238deeb388e2)
![image](https://github.com/user-attachments/assets/680374ea-e4fd-4b51-9066-18099f0a9b5c)
